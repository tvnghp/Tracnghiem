<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>B√†i ki·ªÉm tra tr·∫Øc nghi·ªám Chi nh√°nh C·∫ßn Th∆° II</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="mobile-enhancements.css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <meta name="theme-color" content="#800020">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Quiz C·∫ßn Th∆° II">
<style>
  .modal {
    position: fixed; left: 0; top: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.25); display: flex; align-items: center; justify-content: center;
    z-index: 9999;
  }
  .modal.hidden { display: none; }
  .modal-content {
    background: #fff; border-radius: 10px; padding: 32px 24px 24px 24px; box-shadow: 0 8px 32px rgba(128,0,32,0.13);
    max-width: 340px; text-align: center;
  }
  .modal-content h3 { margin-top: 0; color: #800020; }
  .modal-actions { margin-top: 22px; display: flex; gap: 16px; justify-content: center; }
  .modal-actions .btn { min-width: 120px; }
  
  /* Mobile-specific quiz enhancements */
  @media (max-width: 768px) {
    .modal-content {
      max-width: 95vw;
      margin: 20px;
      padding: 24px 20px;
    }
    
    .modal-actions {
      flex-direction: column;
      gap: 12px;
    }
    
    .modal-actions .btn {
      width: 100%;
      min-width: auto;
    }
    
    .quiz-meta {
      flex-direction: column !important;
      align-items: flex-start !important;
      gap: 12px !important;
      margin-top: 16px !important;
    }
    
    #question-counter {
      font-size: 16px !important;
      font-weight: 600 !important;
    }
    
    #timer {
      font-size: 16px !important;
      padding: 8px 12px !important;
      border-radius: 8px !important;
      background: #f8f9fa !important;
    }
    
    .btn-icon {
      width: 44px !important;
      height: 44px !important;
      border-radius: 50% !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
    }
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <div class="logo">
        <img src="logo.png" alt="Logo" id="logo-img">
        <div class="logo-text">
          <h1><b>H·ªÜ TH·ªêNG TR·∫ÆC NGHI·ªÜM CHI NH√ÅNH C·∫¶N TH∆† II</b></h1>
          <p id="topic-name"></p>
        </div>
      </div>
      <div class="quiz-progress">
        <div id="progress-bar"></div>
      </div>
      <div class="quiz-meta" style="display:flex; justify-content:space-between; align-items:center; margin-top:6px;">
        <div id="question-counter">C√¢u 1/10</div>
        <div style="display:flex; align-items:center; gap:8px;">
          <div id="timer" class="timer" style="font-weight:600; color:#800020"></div>
          <button id="pause-btn" class="btn-icon" style="display:none" title="T·∫°m d·ª´ng/ti·∫øp t·ª•c">
            <i class="material-icons">pause</i>
          </button>
        </div>
      </div>
    </header>    
    <div class="content">
      <div id="question-container">
        <div class="question-header">
          <div id="question" class="question"></div>
          <div class="question-meta">
            <button id="show-flagged-btn" class="btn btn-outline" title="Xem c√°c c√¢u ƒë√£ ƒë√°nh d·∫•u">
              <i class="material-icons">bookmark</i>
              <span id="flag-count">0</span>
            </button>
          </div>
        </div>
        <div id="answers" class="answers"></div>
        <div id="explanation" class="explanation"></div>
      </div>

      <div class="quiz-controls">
        <button id="prev-btn" class="btn btn-primary">
  <i class="material-icons">navigate_before</i> C√¢u tr∆∞·ªõc
</button>
        <div class="quiz-actions">
          <button id="flag-btn" class="btn btn-flag">
            <i class="material-icons">bookmark_border</i> ƒê√°nh d·∫•u
          </button>
          <button id="submit-quiz-btn" class="btn btn-danger">
            <i class="material-icons">send</i> N·ªôp b√†i
          </button>
        </div>
        <button id="next-btn" class="btn btn-primary">
          C√¢u ti·∫øp <i class="material-icons">navigate_next</i>
        </button>
      </div>

      <!-- Review Panel -->
      <div id="review-panel" class="review-panel">
        <div class="review-header">
          <h3><i class="material-icons">bookmark</i> C√°c c√¢u ƒë√£ ƒë√°nh d·∫•u</h3>
          <button id="close-review" class="btn btn-icon">
            <i class="material-icons">close</i>
          </button>
        </div>
        <div id="flagged-questions" class="flagged-questions">
          <!-- Flagged questions will be inserted here -->
        </div>
      </div>

      <div id="result" class="result-panel"></div>
    </div>
  
<!-- Modal h·ªèi ti·∫øp t·ª•c session -->
  <div id="session-modal" class="modal hidden">
    <div class="modal-content">
      <h3>Ti·∫øp t·ª•c b√†i ki·ªÉm tra?</h3>
        <p>B·∫°n ƒë√£ c√≥ m·ªôt phi√™n l√†m b√†i tr∆∞·ªõc ƒë√≥.<br>B·∫°n mu·ªën ti·∫øp t·ª•c hay b·∫Øt ƒë·∫ßu phi√™n m·ªõi?</p>
        <div class="modal-actions">
          <button id="resume-btn" class="btn btn-primary">Ti·∫øp t·ª•c phi√™n c≈©</button>
          <button id="new-session-btn" class="btn btn-outline">B·∫Øt ƒë·∫ßu m·ªõi</button>
        </div>
    </div>
  </div>
  <script>
    // DOM Elements
    const questionEl = document.getElementById('question');
    const answersEl = document.getElementById('answers');
    const progressEl = document.getElementById('progress-bar');
    const questionCounterEl = document.getElementById('question-counter');
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const submitBtn = document.getElementById('submit-quiz-btn');
    const flagBtn = document.getElementById('flag-btn');
    const showFlaggedBtn = document.getElementById('show-flagged-btn');
    const flagCountEl = document.getElementById('flag-count');
    const reviewPanel = document.getElementById('review-panel');
    const closeReviewBtn = document.getElementById('close-review');
    const flaggedQuestionsEl = document.getElementById('flagged-questions');
    const explanationEl = document.getElementById('explanation');
    const resultArea = document.getElementById('result');
    const timerEl = document.getElementById('timer');
    const pauseBtn = document.getElementById('pause-btn');

    // Quiz state
    let topicId = null;
    let topics = [];
    let topic = null;
    let questions = [];
    let currentQuestionIndex = 0;
    let userAnswers = [];
    let quizSubmitted = false;
    let timerInterval = null;
    let endTimeMs = null;
    let isPaused = false;
function scrollToQuestion() {
  // ∆Øu ti√™n ph·∫ßn t·ª≠ ƒëang hi·ªÉn th·ªã n·ªôi dung c√¢u h·ªèi
  const el = document.getElementById('question') 
          || document.querySelector('.question-text') 
          || document.getElementById('question-container');

  if (!el) return;

  // Cho ph√©p focus t·∫°m ƒë·ªÉ .focus() kh√¥ng l·ªói tr√™n m·ªôt s·ªë tr√¨nh duy·ªát
  if (!el.hasAttribute('tabindex')) el.setAttribute('tabindex', '-1');

  // Cu·ªôn m∆∞·ª£t l√™n v√πng c√¢u h·ªèi v√† ƒë·∫∑t focus (kh√¥ng cu·ªôn l·∫ßn 2)
  requestAnimationFrame(() => {
    el.scrollIntoView({ behavior: 'smooth', block: 'start' });
    el.focus({ preventScroll: true });
  });
}

    // Shuffle helpers
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function shuffleOptions(question) {
      const letterPool = ["A", "B", "C", "D"];
      const pairs = (question.optionLabels || []).map((label, idx) => ({
        label: label,
        text: question.options[idx]
      }));
      // determine correct option text before shuffling
      const correctIndex = (question.optionLabels || []).indexOf(question.answer);
      const correctText = correctIndex >= 0 ? question.options[correctIndex] : null;
      shuffleArray(pairs);
      // reassign labels A..D in new order and options accordingly
      question.optionLabels = pairs.map((_, idx) => letterPool[idx]);
      question.options = pairs.map(p => p.text);
      // set new correct label by matching text
      if (correctText !== null) {
        const newIndex = question.options.findIndex(t => t === correctText);
        if (newIndex >= 0) {
          question.answer = question.optionLabels[newIndex];
        }
      }
    }

    function shuffleQuestionsAndOptions() {
      // shuffle options within each question first
      questions.forEach(q => shuffleOptions(q));
      // then shuffle question order
      shuffleArray(questions);
    }

    // Initialize quiz
    async function initQuiz() {
  topicId = getTopicId();
  const progressKey = `quiz_progress_${topicId}`;
  const oldSession = localStorage.getItem(progressKey);

  if (oldSession) {
    // Hi·ªÉn th·ªã modal h·ªèi ng∆∞·ªùi d√πng (cho c·∫£ chuy√™n ƒë·ªÅ v√† b√†i thi)
    const modal = document.getElementById('session-modal');
    modal.classList.remove('hidden');
    return new Promise(resolve => {
      document.getElementById('resume-btn').onclick = () => {
        modal.classList.add('hidden');
        resolve();
      };
      document.getElementById('new-session-btn').onclick = () => {
        localStorage.removeItem(progressKey);
        // reset timer key as well when starting new session
        localStorage.removeItem(`quiz_timer_end_${topicId}`);
        // clear cached exam question set to force a fresh randomization
        localStorage.removeItem(`quiz_exam_questions_${topicId}`);
        modal.classList.add('hidden');
        resolve();
      };
    }).then(() => continueInitQuiz());
  } else {
    continueInitQuiz();
  }
}

async function continueInitQuiz() {
  topics = JSON.parse(localStorage.getItem('quiz_topics') || '[]');
  topic = topics.find(t => t.id === topicId);

  if (!topic) {
    try {
      const url = new URL('./topics.json', location.href);
      url.searchParams.set('v', Date.now());
      const resp = await fetch(url, { cache: 'no-store' });
      if (resp.ok) {
        const remoteTopics = await resp.json();
        if (Array.isArray(remoteTopics) && remoteTopics.length > 0) {
          localStorage.setItem('quiz_topics', JSON.stringify(remoteTopics));
          topics = remoteTopics;
          topic = topics.find(t => t.id === topicId);
        }
      }
    } catch (e) {
      // ignore fetch errors and fall through to error display
    }
  }

  if (!topic) {
    showError('Kh√¥ng t√¨m th·∫•y chuy√™n ƒë·ªÅ!');
    return;
  }

  document.getElementById('topic-name').textContent = topic.name;
  // For exams, assemble questions per attempt using current topics based on examConfig
  if (topic.isExam === true && topic.examConfig && Array.isArray(topic.examConfig.distribution)) {
    questions = getOrCreateExamSessionQuestions(topic);
  } else {
    questions = topic.questions || [];
  }

  if (questions.length === 0) {
    showError('Chuy√™n ƒë·ªÅ n√†y ch∆∞a c√≥ c√¢u h·ªèi!');
    return;
  }

  // Shuffle questions and answers n·∫øu kh√¥ng c√≥ saved progress
  const hasSavedProgress = !!localStorage.getItem(`quiz_progress_${topicId}`);
  if (!hasSavedProgress) {
    shuffleQuestionsAndOptions();
  }

  // Initialize user answers
  userAnswers = questions.map((q, index) => ({
    answer: null,
    correct: null,
    flagged: false,
    explanationShown: false
  }));

  // Load saved progress n·∫øu c√≥
  loadProgress();

  // Initialize event listeners
  initEventListeners();

  // Show first question
  showQuestion(currentQuestionIndex);

  // Initialize countdown timer (use topic duration or ask user)
  const effectiveMinutes = getEffectiveDurationMinutes();
  if (effectiveMinutes > 0) {
    startOrResumeTimer(effectiveMinutes);
  } else if (timerEl) {
    timerEl.style.display = 'none';
  }

  // Setup Pause/Resume if allowed
  if (pauseBtn) {
    if (topic.allowPause) {
      pauseBtn.style.display = 'inline-flex';
      pauseBtn.addEventListener('click', togglePauseResume);
      // restore paused state if any
      const pausedKey = `quiz_timer_paused_${topicId}`;
      const remainingKey = `quiz_timer_remaining_${topicId}`;
      const pausedSaved = localStorage.getItem(pausedKey) === 'true';
      if (pausedSaved) {
        isPaused = true;
        const remain = parseInt(localStorage.getItem(remainingKey) || '0', 10);
        if (remain > 0) {
          endTimeMs = Date.now() + remain; // keep a reference
          updateTimerDisplay(remain);
        }
        setPausedUI(true);
      }
    } else {
      pauseBtn.style.display = 'none';
    }
  }
}

    function loadProgress() {
      const savedProgress = localStorage.getItem(`quiz_progress_${topicId}`);
      if (savedProgress) {
        try {
          const progress = JSON.parse(savedProgress);
          if (progress.answers) userAnswers = progress.answers;
          if (progress.currentIndex !== undefined) currentQuestionIndex = progress.currentIndex;
          if (progress.quizSubmitted) quizSubmitted = progress.quizSubmitted;
        } catch (e) {
          console.error('Error loading progress:', e);
        }
      }
    }

    function saveProgress() {
      const progress = {
        answers: userAnswers,
        currentIndex: currentQuestionIndex,
        quizSubmitted: quizSubmitted,
        timestamp: new Date().toISOString()
      };
      localStorage.setItem(`quiz_progress_${topicId}`, JSON.stringify(progress));
    }

    // ===== Exam assembly per attempt =====
    function getOrCreateExamSessionQuestions(examTopic) {
      const cacheKey = `quiz_exam_questions_${examTopic.id}`;
      const cached = localStorage.getItem(cacheKey);
      if (cached) {
        try {
          const parsed = JSON.parse(cached);
          if (Array.isArray(parsed) && parsed.length > 0) return parsed;
        } catch (_) {}
      }
      const built = buildExamQuestions(examTopic);
      if (Array.isArray(built) && built.length > 0) {
        localStorage.setItem(cacheKey, JSON.stringify(built));
      }
      return built;
    }

    function buildExamQuestions(examTopic) {
      const allTopics = JSON.parse(localStorage.getItem('quiz_topics') || '[]');
      const dist = examTopic.examConfig?.distribution || [];
      const total = parseInt(examTopic.examConfig?.total || 0, 10);
      if (!Array.isArray(dist) || !Number.isFinite(total) || total <= 0) {
        return examTopic.questions || [];
      }

      // Calculate allocation similar to admin builder
      const withCalc = dist.map(d => ({ id: d.id, percent: d.percent, exact: (total * d.percent) / 100 }));
      let allocated = withCalc.map(x => ({ id: x.id, count: Math.floor(x.exact), frac: x.exact - Math.floor(x.exact) }));
      let assigned = allocated.reduce((s, a) => s + a.count, 0);
      let remain = total - assigned;
      if (remain > 0) {
        allocated.sort((a, b) => b.frac - a.frac);
        for (let i = 0; i < allocated.length && remain > 0; i++) { allocated[i].count += 1; remain--; }
      }

      // Sample per topic
      const combined = [];
      for (const a of allocated) {
        const t = allTopics.find(t => t.id === a.id);
        if (!t || !Array.isArray(t.questions)) {
          // Missing topic; fallback to existing exam questions
          return examTopic.questions || [];
        }
        if (a.count > t.questions.length) {
          // Not enough questions; fallback
          return examTopic.questions || [];
        }
        const copy = t.questions.slice();
        // shuffle
        for (let i = copy.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [copy[i], copy[j]] = [copy[j], copy[i]]; }
        combined.push(...copy.slice(0, a.count));
      }
      // final shuffle
      for (let i = combined.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [combined[i], combined[j]] = [combined[j], combined[i]]; }
      return combined;
    }

    // Determine duration: Only exams have/ask for duration.
    // Prefer topic.durationMinutes; if missing and this IS an exam, ask once and cache.
    function getEffectiveDurationMinutes() {
      if (typeof topic.durationMinutes === 'number' && topic.durationMinutes > 0) {
        return topic.durationMinutes;
      }
      // If not an exam, do not ask for time; no timer for normal topics.
      if (topic.isExam !== true) return 0;
      try {
        const key = `quiz_custom_duration_${topicId}`;
        const saved = localStorage.getItem(key);
        let minutes = saved ? parseInt(saved, 10) : NaN;
        if (!Number.isFinite(minutes) || minutes <= 0) {
          const input = prompt('Nh·∫≠p th·ªùi gian l√†m b√†i (ph√∫t):', '30');
          if (input === null) return 0; // user canceled
          minutes = parseInt(input, 10);
          if (!Number.isFinite(minutes) || minutes <= 0) return 0;
          localStorage.setItem(key, String(minutes));
        }
        return minutes;
      } catch (e) {
        return 0;
      }
    }

    // ===== Timer Logic =====
    function formatTime(ms) {
      const totalSec = Math.max(0, Math.floor(ms / 1000));
      const h = Math.floor(totalSec / 3600);
      const m = Math.floor((totalSec % 3600) / 60);
      const s = totalSec % 60;
      const pad = (n) => n.toString().padStart(2,'0');
      return h > 0 ? `${pad(h)}:${pad(m)}:${pad(s)}` : `${pad(m)}:${pad(s)}`;
    }

    function updateTimerDisplay(remainMs){
      if (!timerEl) return;
      timerEl.textContent = formatTime(remainMs);
      timerEl.classList.remove('warning','danger');
      if (remainMs <= 60 * 1000) {
        timerEl.classList.add('danger');
      } else if (remainMs <= 120 * 1000) {
        timerEl.classList.add('warning');
      }
    }

    function updateTimer() {
      if (!endTimeMs || !timerEl) return;
      const remain = endTimeMs - Date.now();
      updateTimerDisplay(remain);
      if (remain <= 0) {
        clearInterval(timerInterval);
        timerInterval = null;
        if (!quizSubmitted) {
          alert('H·∫øt th·ªùi gian. B√†i s·∫Ω ƒë∆∞·ª£c n·ªôp t·ª± ƒë·ªông.');
          submitQuiz();
        }
      }
    }

    function startOrResumeTimer(durationMinutes) {
      const key = `quiz_timer_end_${topicId}`;
      const pausedKey = `quiz_timer_paused_${topicId}`;
      const remainingKey = `quiz_timer_remaining_${topicId}`;
      const saved = localStorage.getItem(key);
      const pausedSaved = localStorage.getItem(pausedKey) === 'true';
      if (saved) {
        endTimeMs = parseInt(saved, 10);
      } else {
        endTimeMs = Date.now() + durationMinutes * 60 * 1000;
        localStorage.setItem(key, String(endTimeMs));
      }
      if (timerEl) timerEl.style.display = 'block';
      if (pausedSaved) {
        // display remaining time without ticking
        isPaused = true;
        const remain = parseInt(localStorage.getItem(remainingKey) || '0', 10);
        updateTimerDisplay(remain > 0 ? remain : (endTimeMs - Date.now()));
        setPausedUI(true);
      } else {
        updateTimer();
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(updateTimer, 1000);
      }
    }

    function togglePauseResume(){
      if (isPaused) {
        resumeTimer();
      } else {
        pauseTimer();
      }
    }

    function pauseTimer(){
      if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
      const remain = Math.max(0, endTimeMs - Date.now());
      localStorage.setItem(`quiz_timer_paused_${topicId}`, 'true');
      localStorage.setItem(`quiz_timer_remaining_${topicId}`, String(remain));
      isPaused = true;
      setPausedUI(true);
      updateTimerDisplay(remain);
    }

    function resumeTimer(){
      const remainingKey = `quiz_timer_remaining_${topicId}`;
      const endKey = `quiz_timer_end_${topicId}`;
      const pausedKey = `quiz_timer_paused_${topicId}`;
      const remain = parseInt(localStorage.getItem(remainingKey) || '0', 10);
      const base = isNaN(remain) || remain <= 0 ? (endTimeMs - Date.now()) : remain;
      endTimeMs = Date.now() + Math.max(0, base);
      localStorage.setItem(endKey, String(endTimeMs));
      localStorage.removeItem(remainingKey);
      localStorage.setItem(pausedKey, 'false');
      isPaused = false;
      setPausedUI(false);
      updateTimer();
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(updateTimer, 1000);
    }

    function setPausedUI(paused){
      if (!pauseBtn) return;
      if (paused) {
        pauseBtn.innerHTML = '<i class="material-icons">play_arrow</i>';
        pauseBtn.title = 'Ti·∫øp t·ª•c';
        // disable interactions while paused
        prevBtn.disabled = true;
        nextBtn.disabled = true;
        submitBtn.disabled = true;
      } else {
        pauseBtn.innerHTML = '<i class="material-icons">pause</i>';
        pauseBtn.title = 'T·∫°m d·ª´ng';
        prevBtn.disabled = currentQuestionIndex === 0;
        nextBtn.disabled = currentQuestionIndex === questions.length - 1;
        submitBtn.disabled = false;
      }
    }

    function showQuestion(index) {
      if (index < 0 || index >= questions.length) return;
      
      currentQuestionIndex = index;
      const question = questions[index];
      const userAnswer = userAnswers[index];
      
      // Update question number display (single source)
      if (questionCounterEl) {
        questionCounterEl.textContent = `C√¢u ${index + 1}/${questions.length}`;
      }
      
      // Update question text
      questionEl.textContent = question.question;
      
      // Update answers
      answersEl.innerHTML = '';
      question.optionLabels.forEach((label, i) => {
        const answer = question.options[i];
        const answerEl = document.createElement('div');
        const isSelected = userAnswer.answer === label;
        const isCorrect = label === question.answer;
        const reveal = quizSubmitted || userAnswer.answer !== null;
        
        let answerClass = 'answer';
        if (isSelected) answerClass += ' selected';
        if (reveal) {
          if (isCorrect) answerClass += ' correct';
          if (isSelected && !isCorrect) answerClass += ' incorrect';
        }
        
        answerEl.className = answerClass;
        answerEl.innerHTML = `
          <span class="option">${label}.</span>
          <span class="text">${answer}</span>
        `;
        
        if (!quizSubmitted || (quizSubmitted && !isSelected && !isCorrect)) {
          answerEl.onclick = () => selectAnswer(label);
        }
        
        answersEl.appendChild(answerEl);
      });

      // Update flag button
      updateFlagButton();
      
      // Show explanation if available and shown before
      if (userAnswer.explanationShown && question.explain) {
        showExplanation(question.explain);
      } else {
        explanationEl.style.display = 'none';
      }
      
      // Update navigation
      updateNavigation();
      updateProgress();
// ... cu·ªëi showQuestion(index):
scrollToQuestion();
updateNextBtnStatus();


    }

    function updateFlagButton() {
      const isFlagged = userAnswers[currentQuestionIndex].flagged;
      flagBtn.innerHTML = `
        <i class="material-icons">${isFlagged ? 'bookmark' : 'bookmark_border'}</i>
        ${isFlagged ? 'B·ªè ƒë√°nh d·∫•u' : 'ƒê√°nh d·∫•u'}
      `;
      flagBtn.classList.toggle('active', isFlagged);
      
      // Update flag count
      const flagCount = userAnswers.filter(a => a.flagged).length;
      flagCountEl.textContent = flagCount > 0 ? flagCount : '';
      showFlaggedBtn.style.display = flagCount > 0 ? 'flex' : 'none';
    }

    function updateNavigation() {
      prevBtn.disabled = currentQuestionIndex === 0;
      nextBtn.disabled = currentQuestionIndex === questions.length - 1;
      
      // Submit is always available
      submitBtn.style.display = 'inline-flex';
      
      // Hide next on last question
      if (currentQuestionIndex === questions.length - 1) {
        nextBtn.style.display = 'none';
      } else {
        nextBtn.style.display = 'inline-flex';
      }
    }

    function updateProgress() {
      const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
      progressEl.style.width = `${progress}%`;
    }

    function selectAnswer(answer) {
      if (quizSubmitted || isPaused) return;
      
      const userAnswer = userAnswers[currentQuestionIndex];
      userAnswer.answer = answer;
      userAnswer.correct = answer === questions[currentQuestionIndex].answer;
      
      // Show explanation if available
      const question = questions[currentQuestionIndex];
      if (question.explain) {
        showExplanation(question.explain);
        userAnswer.explanationShown = true;
      }
      
      // Update UI
      showQuestion(currentQuestionIndex);
      saveProgress();
updateNextBtnStatus();

requestAnimationFrame(() => {
  const btn = document.getElementById('next-btn') || (typeof nextBtn !== 'undefined' ? nextBtn : null);
  if (!btn) return;

  // Cho ph√©p focus t·∫°m th·ªùi ƒë·ªÉ .focus() kh√¥ng l·ªói
  if (!btn.hasAttribute('tabindex')) btn.setAttribute('tabindex', '-1');

  // Cu·ªôn n√∫t v√†o gi·ªØa m√†n h√¨nh
  btn.scrollIntoView({ behavior: 'smooth', block: 'center' });

  // ƒê·∫∑t focus (kh√¥ng g√¢y cu·ªôn l·∫°i) v√† nh√°y nh·∫π
  btn.focus({ preventScroll: true });
  btn.classList.add('pulse');
  setTimeout(() => btn.classList.remove('pulse'), 600);
});

    }

    function showExplanation(text) {
      explanationEl.innerHTML = `
        <h4><i class="material-icons">info</i> Gi·∫£i th√≠ch</h4>
        <p>${text}</p>
      `;
      explanationEl.style.display = 'block';
    }

    function toggleFlag() {
      if (isPaused) return;
      userAnswers[currentQuestionIndex].flagged = !userAnswers[currentQuestionIndex].flagged;
      updateFlagButton();
      saveProgress();
    }

    function showFlaggedQuestions() {
      if (isPaused) return;
      const flaggedIndices = [];
      userAnswers.forEach((ua, index) => {
        if (ua.flagged) flaggedIndices.push(index);
      });
      
      if (flaggedIndices.length === 0) {
        flaggedQuestionsEl.innerHTML = '<p class="no-flagged">Kh√¥ng c√≥ c√¢u h·ªèi n√†o ƒë∆∞·ª£c ƒë√°nh d·∫•u</p>';
      } else {
        const flaggedList = flaggedIndices.map(index => {
          const q = questions[index];
          const ua = userAnswers[index];
          const isCorrect = ua.answer === q.answer;
          
          return `
            <div class="flagged-question" data-index="${index}">
              <div class="question">${index + 1}. ${q.question}</div>
              <div class="answer-status ${isCorrect ? 'correct' : 'incorrect'}">
                ${isCorrect ? '‚úì ƒê√£ tr·∫£ l·ªùi ƒë√∫ng' : '‚úó Ch∆∞a tr·∫£ l·ªùi'}
              </div>
              ${quizSubmitted && q.explain ? `
                <div class="explanation">
                  <strong>Gi·∫£i th√≠ch:</strong> ${q.explain}
                </div>
              ` : ''}
            </div>
          `;
        }).join('');
        
        flaggedQuestionsEl.innerHTML = flaggedList;
        
        // Add click handler to flagged questions
        document.querySelectorAll('.flagged-question').forEach(item => {
          item.addEventListener('click', () => {
            const index = parseInt(item.dataset.index);
            currentQuestionIndex = index;
            showQuestion(index);
            reviewPanel.classList.remove('show');
            document.body.style.overflow = 'auto';
          });
        });
      }
      
      // Show review panel
      reviewPanel.classList.add('show');
      document.body.style.overflow = 'hidden';
    }

    function submitQuiz() {
      if (quizSubmitted) return;
      if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën n·ªôp b√†i kh√¥ng?')) {
        quizSubmitted = true;
        showResults();
        saveProgress();
        // clear timer keys
        localStorage.removeItem(`quiz_timer_end_${topicId}`);
        localStorage.removeItem(`quiz_timer_paused_${topicId}`);
        localStorage.removeItem(`quiz_timer_remaining_${topicId}`);
      }
    }
function getAnswerStatus(index){
  const ua = userAnswers?.[index];
  if (!ua || ua.answer == null) return { text: "Ch∆∞a ch·ªçn", cls: "status-pending" };
  return ua.correct ? { text: "ƒê√É CH·ªåN: ƒê√öNG", cls: "status-correct" }
                    : { text: "ƒê√É CH·ªåN: SAI",  cls: "status-incorrect" };
}

function updateNextBtnStatus(){
  const el = document.getElementById('next-btn') || (typeof nextBtn !== 'undefined' ? nextBtn : null);
  if (!el) return;
  const st = getAnswerStatus(currentQuestionIndex);
  const base = `C√¢u ti·∫øp <i class="material-icons">navigate_next</i>`;
  el.innerHTML = `${base} <span class="status-badge ${st.cls}">${st.text}</span>`;
}

    function showResults() {
      const correctCount = userAnswers.filter(a => a.correct).length;
      const totalQuestions = questions.length;
      const score = Math.round((correctCount / totalQuestions) * 100);
      
      resultArea.innerHTML = `
        <div class="result-container">
          <h2>K·∫øt qu·∫£ b√†i ki·ªÉm tra</h2>
          <div class="score-display">
            <div class="score">${correctCount}<span>/${totalQuestions}</span></div>
            <div class="percentage">${score}%</div>
          </div>
          <div class="result-actions">
            <a href="index.html" class="btn">
              <i class="material-icons">home</i> V·ªÅ trang ch·ªß
            </a>
            <button id="restart-btn" class="btn btn-outline">
              <i class="material-icons">refresh</i> L√†m l·∫°i
            </button>
          </div>
        </div>
      `;
      resultArea.style.display = 'block';
      
      // Attach restart handler once results are shown
      const restartBtn = document.getElementById('restart-btn');
      if (restartBtn) {
        restartBtn.addEventListener('click', () => {
          // Clear quiz progress and reset state to the very beginning
          localStorage.removeItem(`quiz_progress_${topicId}`);
          // Reset timer end and start fresh if timed
          localStorage.removeItem(`quiz_timer_end_${topicId}`);
          // For exams: clear cached selection so a new random set is built
          localStorage.removeItem(`quiz_exam_questions_${topicId}`);
          quizSubmitted = false;
          // Rebuild questions for exams; otherwise reuse topic.questions
          if (topic.isExam === true && topic.examConfig && Array.isArray(topic.examConfig.distribution)) {
            questions = getOrCreateExamSessionQuestions(topic);
          }
          // Shuffle order and options for a new attempt
          shuffleQuestionsAndOptions();
          userAnswers = questions.map(() => ({
            answer: null,
            correct: null,
            flagged: false,
            explanationShown: false
          }));
          currentQuestionIndex = 0;
          resultArea.innerHTML = '';
          resultArea.style.display = 'none';
          showQuestion(0);
          saveProgress();
          const ef = getEffectiveDurationMinutes();
          if (ef > 0) {
            startOrResumeTimer(ef);
          }
        }, { once: true });
      }
      
      // Show all explanations for review
      questions.forEach((q, index) => {
        if (q.explain) {
          userAnswers[index].explanationShown = true;
        }
      });
      
      // Show first question with explanations
      showQuestion(0);
    }

    function initEventListeners() {
      // Navigation
      prevBtn.addEventListener('click', () => {
        if (isPaused) return;
        if (currentQuestionIndex > 0) {
          showQuestion(currentQuestionIndex - 1);
        }
      });

      nextBtn.addEventListener('click', () => {
        if (isPaused) return;
        if (currentQuestionIndex < questions.length - 1) {
          showQuestion(currentQuestionIndex + 1);
        }
      });

      // Submit quiz
      submitBtn.addEventListener('click', submitQuiz);
      
      // Flag question
      flagBtn.addEventListener('click', toggleFlag);
      
      // Show flagged questions
      showFlaggedBtn.addEventListener('click', showFlaggedQuestions);
      
      // Close review panel
      closeReviewBtn.addEventListener('click', () => {
        reviewPanel.classList.remove('show');
        document.body.style.overflow = 'auto';
      });
      
      // Close review panel when clicking outside
      reviewPanel.addEventListener('click', (e) => {
        if (e.target === reviewPanel) {
          reviewPanel.classList.remove('show');
          document.body.style.overflow = 'auto';
        }
      });
      
      // Keyboard navigation
      document.addEventListener('keydown', (e) => {
        if (isPaused) return;
        if (e.key === 'ArrowLeft' && currentQuestionIndex > 0) {
          showQuestion(currentQuestionIndex - 1);
        } else if (e.key === 'ArrowRight' && currentQuestionIndex < questions.length - 1) {
          showQuestion(currentQuestionIndex + 1);
        } else if (e.key === ' ' || e.key === 'Enter') {
          if (!e.target.matches('button, a, input, textarea')) {
            e.preventDefault();
            const selected = document.querySelector('.answer:not(.selected)');
            if (selected) selected.click();
          }
        } else if (e.key === 'f' || e.key === 'F') {
          e.preventDefault();
          toggleFlag();
        } else if (e.key === 'Escape') {
          reviewPanel.classList.remove('show');
          document.body.style.overflow = 'auto';
        }
      });
    }

    function getTopicId() {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('topic');
    }

    function showError(message) {
      document.body.innerHTML = `
        <div class="error-message">
          <h2>${message}</h2>
          <p>Vui l√≤ng quay l·∫°i trang ch·ªß v√† th·ª≠ l·∫°i.</p>
          <a href="index.html" class="btn">
            <i class="material-icons">home</i> V·ªÅ trang ch·ªß
          </a>
        </div>
      `;
    }

    // Initialize the quiz
    document.addEventListener('DOMContentLoaded', initQuiz);
  </script>
  <footer class="footer-copyright" style="text-align: center; padding: 20px; margin-top: 40px; background: #f8f6f8; border-top: 1px solid #eee; color: #800020;">
    <strong>B·∫£n quy·ªÅn ¬© 2025 H·ªá th·ªëng √¥n luy·ªán tr·∫Øc nghi·ªám C·∫ßn Th∆° II.</strong><br>  
    Li√™n h·ªá: Nguy·ªÖn Th√†nh Trung
    üì± Cellphone: 0947.86.86.82
    üìß Email: trungnguyenthanh1@agribank.com.vn
  </footer>
  <script src="mobile-touch.js"></script>
</body>
</html>

